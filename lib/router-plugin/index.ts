import * as fsp from 'node:fs/promises';
import * as path from 'node:path';

import { type Plugin } from 'vite';

import { type RouteManifest, defineRoutes, normalizeSlashes } from './utils';

type Promisable<T> = Promise<T> | T;

export interface RouterPluginOptions {
	dir: string;
	typedDist: string;
	routeDist: string;
	routes: (path: string, defineRoute: typeof defineRoutes) => Promisable<RouteManifest>;
}

const routerPlugin = (options: RouterPluginOptions): Plugin => {
	const { dir, routeDist, typedDist, routes } = options;

	const generate = debounce(() => generateRoutes(resolvedOptions), 250);
	let resolvedOptions: RouterPluginOptions;

	return {
		name: '@intrnl/vite-solid-router',
		enforce: 'pre',
		configResolved(config) {
			const root = config.root;

			resolvedOptions = {
				dir: path.resolve(root, dir),
				routeDist: path.resolve(root, routeDist),
				typedDist: path.resolve(root, typedDist),
				routes,
			};
		},
		configureServer(server) {
			const listener = (path: string) => {
				if (path.startsWith(resolvedOptions.dir)) {
					generate();
				}
			};

			server.watcher.on('add', listener);
			server.watcher.on('unlink', listener);
		},
		buildStart() {
			generate();
		},
	};
};

export default routerPlugin;

const debounce = <F extends (...params: any[]) => void>(fn: F, delay: number) => {
	let timeout: any;

	return function () {
		const args = arguments;

		clearTimeout(timeout);
		timeout = setTimeout(() => fn.apply(this, args), delay);
	} as (...params: Parameters<F>) => void;
};

const INDENT = '  ';

const generateRoutes = async (options: RouterPluginOptions) => {
	const { dir, routeDist, typedDist, routes } = options;

	const manifest = await routes(dir, defineRoutes);

	await fsp.writeFile(routeDist, generateRouterRoutes(dir, routeDist, manifest));
	await fsp.writeFile(typedDist, generateRouterTypes(manifest));
};

const join = (paths: string[]) => {
	let res = '';

	for (let idx = 0, len = paths.length; idx < len; idx++) {
		let segment = paths[idx];

		if (segment) {
			res && (res += '/');
			res += segment;
		}
	}

	return res;
};

const generateRouterTypes = (manifest: RouteManifest) => {
	const pathsWParams: string[] = [];
	const pathsWOParams: string[] = [];

	const pathsParams: Record<string, string[]> = {};

	const set = new Set<string>();

	let wParamsType = 'never';
	let woParamsType = 'never';
	let pathsParamsIntf = '';

	const recurseRoute = (parentId?: string, prefix = '') => {
		for (const routeId in manifest) {
			const child = manifest[routeId];

			if (child.parentId !== parentId) {
				continue;
			}

			if (child.path || child.index) {
				const relname = join([prefix, child.path || '']);
				const pathname = '/' + relname;
				const segments = pathname.split('/');

				if (!set.has(pathname)) {
					set.add(pathname);

					const params = [];

					for (let idx = 0, len = segments.length; idx < len; idx++) {
						const segment = segments[idx];

						if (segment[0] === ':') {
							params.push(segment.slice(1));
						} else if (segment === '*') {
							params.push('*');
						}
					}

					if (params.length > 0) {
						pathsWParams.push(pathname);
						pathsParams[pathname] = params;
					} else {
						pathsWOParams.push(pathname);
					}
				}

				recurseRoute(child.id, relname);
			} else {
				recurseRoute(child.id, prefix);
			}
		}
	};

	recurseRoute();

	if (pathsWParams.length > 0) {
		wParamsType = '';

		for (let idx = 0, len = pathsWParams.length; idx < len; idx++) {
			const pathname = pathsWParams[idx];

			wParamsType += `\n\t| ${JSON.stringify(pathname)}`;
		}
	}

	if (pathsWOParams.length > 0) {
		woParamsType = '';

		for (let idx = 0, len = pathsWOParams.length; idx < len; idx++) {
			const pathname = pathsWOParams[idx];

			woParamsType += `\n\t| ${JSON.stringify(pathname)}`;
		}
	}

	if (Object.keys(pathsParams).length > 0) {
		pathsParamsIntf = `\n`;

		for (const pathname in pathsParams) {
			const keys = pathsParams[pathname];

			pathsParamsIntf += `\t${JSON.stringify(pathname)}: { `;

			for (let idx = 0, len = keys.length; idx < len; idx++) {
				const end = idx === len - 1;

				const key = keys[idx];
				const optional = key[key.length - 1] === '?';

				const name = optional ? key.slice(0, -1) : key;

				pathsParamsIntf += `${JSON.stringify(name)}${optional ? '?' : ''}: string${end ? '' : ','} `;
			}

			pathsParamsIntf += `};\n`;
		}
	}

	const sauce = `
// This file is automatically generated, do not edit.
import {
	type NavigateOptions,
	useNavigate as useNavigate_,
	useParams as useParams_,
} from "@solidjs/router";

export type PathsWithParams = ${wParamsType};
export type PathsWithoutParams = ${woParamsType};
export type Paths = PathsWithParams | PathsWithoutParams;

export interface Params {${pathsParamsIntf}}

type NavigateWithParamOptions<P> = P extends number
	? []
	: P extends PathsWithParams
		? [Partial<NavigateOptions> & { params: Params[P] }]
		: [Partial<NavigateOptions> & { params?: never }] | [];

export const useParams: <P extends PathsWithParams>(path: P) => Params[P] = useParams_ as any;
export const useNavigate = (): (<P extends Paths | number>(
	href: P,
	...options: NavigateWithParamOptions<P>
) => void) => {
	const navigate = useNavigate_();
	return ((path: any, options: any) => {
		if (typeof path === "number") {
			return navigate(path);
		}

		const finalizedPath = generatePath(path, options?.params);
		return navigate(finalizedPath, options);
	}) as any;
};

const RE_PARAM = /\\/:(\\w+)(\\??)/g;
export const generatePath = ((path: string, params: Record<string, string> | undefined) => {
	if (!params) {
		return path;
	}

  return path.replace(RE_PARAM, (_, segment) =>
    (params as any)[segment] ? \`/\${(params as any)[segment]}\` : ""
  );
}) as GeneratePathFunction;

interface GeneratePathFunction {
  <P extends PathsWithoutParams>(path: P): string;
  <P extends PathsWithParams>(path: P, params: Params[P]): string;
}
`;

	return sauce;
};

const generateRouterRoutes = (dir: string, routeDist: string, manifest: RouteManifest) => {
	const rel = normalizeSlashes(path.relative(path.dirname(routeDist), dir));

	let jsBanner = '';
	let jsImports = '';
	let jsSource = '';

	jsBanner += `// This file is automatically generated, do not edit.\n\n`;

	jsBanner += `/* eslint-disable */\n`;
	// jsBanner += `// @ts-nocheck\n`;

	jsImports += `import { lazy } from "solid-js";\n`;
	jsImports += `import { type RouteDefinition } from "@solidjs/router";\n`;

	const recurseRoute = (parentId?: string, level: number = 0) => {
		const baseIndent = pad(level + 1, INDENT);
		const objIndent = pad(level + 2, INDENT);

		let hasChildren = false;
		let source = '';
		source += `[\n`;

		for (const routeId in manifest) {
			const child = manifest[routeId];

			if (child.parentId !== parentId) {
				continue;
			}

			let path = child.path || '/';

			if (path.endsWith('/*')) {
				path += '*';
			}

			hasChildren = true;
			source += `${baseIndent}{\n`;

			source += `${objIndent}path: ${JSON.stringify(path)},\n`;

			if (child.file) {
				const pathname = joinPath(rel, child.file);

				source += `${objIndent}component: lazy(() => import(${JSON.stringify(pathname)})),\n`;
			}

			const childResult = recurseRoute(child.id, level + 2);

			if (childResult) {
				source += `${objIndent}children: ${childResult},\n`;
			}

			source += `${baseIndent}},\n`;
		}

		if (!hasChildren) {
			return '';
		}

		source += `${pad(level, INDENT)}]`;
		return source;
	};

	jsSource += `const routes: RouteDefinition[] = ` + recurseRoute() + ';\n';
	jsSource += `\n`;
	jsSource += `export default routes;\n`;

	let jsConcat = '';

	if (jsBanner) {
		jsConcat += jsBanner + '\n';
	}
	if (jsImports) {
		jsConcat += jsImports + '\n';
	}
	if (jsSource) {
		jsConcat += jsSource;
	}

	return jsConcat;
};

const pad = (amount: number, str: string) => {
	return str.repeat(amount);
};

const joinPath = (...paths: string[]) => {
	let name = path.posix.join(...paths);

	if (name[0] !== '.' || name[1] !== '.' || name[2] === '/') {
		name = './' + name;
	}

	return name;
};
